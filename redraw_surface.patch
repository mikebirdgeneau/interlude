diff --git a/src/audio.rs b/src/audio.rs
index 97e9862d58ef3d620ee9e1c00455341f0ba1d435..eb4c76e9974212703b50e1bdf831a88a3d6d73a0 100644
--- a/src/audio.rs
+++ b/src/audio.rs
@@ -1,27 +1,27 @@
 use ogg::PacketReader;
-use opus::{Decoder as OpusDecoder, Channels};
+use opus::{Channels, Decoder as OpusDecoder};
 use rodio::{OutputStream, OutputStreamHandle, Sink};
 use std::io::Cursor;
 
 const START_OPUS: &[u8] = include_bytes!("../assets/start.opus");
 const END_OPUS: &[u8] = include_bytes!("../assets/end.opus");
 
 pub struct Audio {
     _stream: OutputStream,
     handle: OutputStreamHandle,
 }
 
 impl Audio {
     pub fn new() -> Option<Self> {
         let (stream, handle) = OutputStream::try_default().ok()?;
         Some(Self {
             _stream: stream,
             handle,
         })
     }
 
     pub fn play_start(&self) {
         play_bytes(&self.handle, START_OPUS);
     }
 
     pub fn play_end(&self) {
diff --git a/src/cli.rs b/src/cli.rs
index 4f00bd15b0cff27b3b36b70dbcc7f28e3ca94a69..18b5d62e17ce22b26a94830f38807b8e90eaa5b8 100644
--- a/src/cli.rs
+++ b/src/cli.rs
@@ -14,28 +14,28 @@ pub struct Cli {
     /// Initial snooze duration in seconds (shrinks each snooze)
     #[arg(long, default_value_t = 300)]
     pub snooze_base_seconds: u64,
 
     /// Snooze decay multiplier applied each time you snooze (0 < decay < 1)
     #[arg(long, default_value_t = 0.6)]
     pub snooze_decay: f64,
 
     /// Minimum snooze duration in seconds
     #[arg(long, default_value_t = 30)]
     pub snooze_min_seconds: u64,
 
     /// Optional: after N snoozes in a cycle, disable snooze (0 = unlimited)
     #[arg(long, default_value_t = 0)]
     pub max_snoozes: u32,
 
     /// Immediately start a break sequence (for testing)
     #[arg(long, default_value_t = false)]
     pub immediate: bool,
 
     /// Background overlay color in hex (#RGB, #RRGGBB, or #RRGGBBAA)
     #[arg(long, default_value = "#000000CC")]
     pub background: String,
 
     /// Foreground text/icon color in hex (#RGB, #RRGGBB, or #RRGGBBAA)
-    #[arg(long, default_value = "#FFFFFDD")]
+    #[arg(long, default_value = "#FFFFFDDD")]
     pub foreground: String,
 }
diff --git a/src/main.rs b/src/main.rs
index 66d340859914a07426ef6603cdae55f92c7ac2fa..126782348379ed7064779004f622cecdd7ff2483 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,124 +1,112 @@
 use anyhow::Result;
 use clap::Parser;
-use crossbeam_channel::{Receiver, unbounded};
+use crossbeam_channel::unbounded;
 
-mod cli;
 mod audio;
+mod cli;
 mod scheduler;
 mod tiny_font;
 mod wayland_lock;
 
+use audio::Audio;
 use cli::Cli;
 use scheduler::{Config, Phase, Scheduler};
 use wayland_lock::{Locker, UiColors, UiEvent, UiMode};
-use audio::Audio;
-
-fn recv_all(rx: &Receiver<UiEvent>) -> Vec<UiEvent> {
-    let mut out = Vec::new();
-    while let Ok(ev) = rx.try_recv() {
-        out.push(ev);
-    }
-    out
-}
 
 fn fmt_duration(d: std::time::Duration) -> String {
     let secs = d.as_secs();
     let m = secs / 60;
     let s = secs % 60;
     format!("{:02}:{:02}", m, s)
 }
 
 fn main() -> Result<()> {
     let args = Cli::parse();
 
     let cfg = Config {
         interval: std::time::Duration::from_secs(args.interval_minutes * 60),
         break_len: std::time::Duration::from_secs(args.break_seconds),
         snooze_base: std::time::Duration::from_secs(args.snooze_base_seconds),
         snooze_decay: args.snooze_decay,
         snooze_min: std::time::Duration::from_secs(args.snooze_min_seconds),
         max_snoozes: if args.max_snoozes == 0 {
             None
         } else {
             Some(args.max_snoozes)
         },
     };
 
     let mut sched = Scheduler::new(cfg);
     let mut last_phase = sched.phase;
     if args.immediate {
         sched.phase = Phase::LockedAwaitingAction;
         sched.deadline = None;
         last_phase = Phase::Working;
     }
 
     let (tx_ui, rx_ui) = unbounded();
     let colors = UiColors {
         background: parse_color(&args.background).unwrap_or([0, 0, 0, 0xCC]),
         foreground: parse_color(&args.foreground).unwrap_or([0xFF, 0xFF, 0xFD, 0xDD]),
     };
     let mut locker = Locker::new(tx_ui, colors)?;
     let audio = Audio::new();
 
     loop {
         // Tick core scheduler
         sched.tick();
 
         // Handle key events
         if !locker.is_fading() {
-            for ev in recv_all(&rx_ui) {
+            for ev in rx_ui.try_iter() {
                 match (sched.phase, ev) {
                     (Phase::LockedAwaitingAction, UiEvent::PressZ)
                     | (Phase::OnBreak, UiEvent::PressZ) => {
                         if sched.can_snooze() {
                             let _d = sched.snooze();
                             if locker.is_locked() {
                                 locker.start_fade_out();
                             }
                         }
                     }
                     (Phase::BreakFinished, UiEvent::PressEnter)
                     | (Phase::BreakFinished, UiEvent::PointerClick)
                     | (Phase::BreakFinished, UiEvent::AnyKey) => {
                         if locker.is_locked() {
                             locker.start_fade_out();
                         }
                     }
                     _ => {}
                 }
             }
         }
 
-        // Ensure lock/unlock based on phase
-        match sched.phase {
-            Phase::Working | Phase::Snoozing => {}
-            Phase::LockedAwaitingAction | Phase::OnBreak | Phase::BreakFinished => {}
-        }
-
-        if matches!(sched.phase, Phase::LockedAwaitingAction | Phase::OnBreak | Phase::BreakFinished)
-            && !locker.is_locked()
+        if matches!(
+            sched.phase,
+            Phase::LockedAwaitingAction | Phase::OnBreak | Phase::BreakFinished
+        ) && !locker.is_locked()
         {
             locker.lock()?;
         }
 
         if sched.phase == Phase::LockedAwaitingAction && last_phase != Phase::LockedAwaitingAction {
             locker.start_fade_in();
         }
 
         if sched.phase == Phase::OnBreak && last_phase != Phase::OnBreak {
             if let Some(audio) = &audio {
                 audio.play_start();
             }
         }
 
         if sched.phase == Phase::BreakFinished && last_phase != Phase::BreakFinished {
             if let Some(audio) = &audio {
                 audio.play_end();
             }
         }
 
         // Update overlay UI mode (only meaningful when locked)
         if locker.is_locked() {
             match sched.phase {
                 Phase::LockedAwaitingAction => {
                     let snooze = sched.snooze_duration().as_secs();
diff --git a/src/scheduler.rs b/src/scheduler.rs
index 8c1de3c5278f24a731ca95fe8cd0efb311e3099f..c7e310112fb15e9196762dadb17718f27c7d63d0 100644
--- a/src/scheduler.rs
+++ b/src/scheduler.rs
@@ -16,103 +16,103 @@ pub struct Config {
     pub snooze_base: Duration,
     pub snooze_decay: f64,
     pub snooze_min: Duration,
     pub max_snoozes: Option<u32>,
 }
 
 #[derive(Debug, Clone)]
 pub struct Scheduler {
     pub phase: Phase,
     pub deadline: Option<Instant>,
     pub snooze_count: u32,
     pub cfg: Config,
 }
 
 impl Scheduler {
     pub fn new(cfg: Config) -> Self {
         Self {
             phase: Phase::Working,
             deadline: Some(Instant::now() + cfg.interval),
             snooze_count: 0,
             cfg,
         }
     }
 
     pub fn tick(&mut self) {
+        let now = Instant::now();
         if let Some(dl) = self.deadline {
-            if Instant::now() >= dl {
+            if now >= dl {
                 match self.phase {
                     Phase::Working => {
                         self.phase = Phase::LockedAwaitingAction;
                         self.deadline = None;
                     }
                     Phase::OnBreak => {
                         self.phase = Phase::BreakFinished;
                         self.deadline = None;
                     }
                     Phase::Snoozing => {
                         self.phase = Phase::LockedAwaitingAction;
                         self.deadline = None;
                     }
                     _ => {}
                 }
             }
         }
     }
 
     pub fn time_left(&self) -> Option<Duration> {
         self.deadline
             .map(|d| d.saturating_duration_since(Instant::now()))
     }
 
     pub fn snooze_duration(&self) -> Duration {
         let base = self.cfg.snooze_base.as_secs_f64();
         let dec = self.cfg.snooze_decay.clamp(0.01, 0.999);
         let dur = base * dec.powi(self.snooze_count as i32);
         let dur = dur.round().max(self.cfg.snooze_min.as_secs_f64());
         Duration::from_secs(dur as u64)
     }
 
     pub fn can_snooze(&self) -> bool {
         match self.cfg.max_snoozes {
             None => true,
             Some(n) => self.snooze_count < n,
         }
     }
 
     pub fn start_break(&mut self) {
         self.phase = Phase::OnBreak;
         self.deadline = Some(Instant::now() + self.cfg.break_len);
     }
 
     pub fn finish_and_restart(&mut self) {
         self.phase = Phase::Working;
         self.deadline = Some(Instant::now() + self.cfg.interval);
         self.snooze_count = 0;
     }
 
-
     pub fn snooze(&mut self) -> Duration {
         let d = self.snooze_duration();
         self.snooze_count = self.snooze_count.saturating_add(1);
         self.phase = Phase::Snoozing;
         self.deadline = Some(Instant::now() + d);
         d
     }
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
     fn test_cfg() -> Config {
         Config {
             interval: Duration::from_secs(10),
             break_len: Duration::from_secs(5),
             snooze_base: Duration::from_secs(100),
             snooze_decay: 0.5,
             snooze_min: Duration::from_secs(30),
             max_snoozes: Some(2),
         }
     }
 
     #[test]
diff --git a/src/shm.rs b/src/shm.rs
index 9e5dea3e7e5447422e800fff90bc4e8994de3d1d..f95d1c407af600fa2a9b264d752b474a7ccb8359 100644
--- a/src/shm.rs
+++ b/src/shm.rs
@@ -1,39 +1,19 @@
 use anyhow::Result;
 use memmap2::MmapMut;
 use rustix::fs::{memfd_create, MemfdFlags};
-use rustix::mm::{mmap, MapFlags, ProtFlags};
-use std::os::fd::{AsFd, FromRawFd, OwnedFd};
-use std::ptr::NonNull;
+use std::os::fd::{AsFd, OwnedFd};
 
 pub struct ShmBuffer {
     pub fd: OwnedFd,
     pub map: MmapMut,
     pub len: usize,
 }
 
 pub fn create_shm(len: usize) -> Result<ShmBuffer> {
     let fd = memfd_create("interlude-shm", MemfdFlags::CLOEXEC)?;
     rustix::fs::ftruncate(&fd, len as u64)?;
 
-    // Map it
-    let ptr = unsafe {
-        mmap(
-            std::ptr::null_mut(),
-            len,
-            ProtFlags::READ | ProtFlags::WRITE,
-            MapFlags::SHARED,
-            &fd,
-            0,
-        )?
-    };
-
-    let nn = NonNull::new(ptr as *mut u8).unwrap();
     let map = unsafe { MmapMut::map_mut(fd.as_fd())? };
 
-    // `map_mut` already mmaps; the above mmap call is redundant in some setups.
-    // Keep this scaffold simple: rely on memmap2â€™s mapping.
-    // If you hit issues, remove the manual `mmap` call above.
-
     Ok(ShmBuffer { fd, map, len })
 }
-
diff --git a/src/wayland_lock.rs b/src/wayland_lock.rs
index e569da20c3a1eade865219235c8296f418fb0846..ce1d4e2f1743fda76ecf6da5caed541097be6e63 100644
--- a/src/wayland_lock.rs
+++ b/src/wayland_lock.rs
@@ -1,94 +1,95 @@
-use anyhow::{anyhow, Result};
+use anyhow::{Result, anyhow};
 use crossbeam_channel::Sender;
 use rustix::fd::IntoRawFd;
 use std::os::fd::{AsFd, FromRawFd};
 
 use wayland_client::{
+    Connection, Dispatch, EventQueue, Proxy, QueueHandle, WEnum,
+    backend::WaylandError,
     protocol::{
         wl_buffer, wl_buffer::WlBuffer, wl_compositor::WlCompositor, wl_keyboard, wl_output,
         wl_output::WlOutput, wl_pointer, wl_region::WlRegion, wl_registry, wl_seat::WlSeat,
         wl_shm::WlShm, wl_shm_pool::WlShmPool, wl_surface::WlSurface,
     },
-    backend::WaylandError, Connection, Dispatch, EventQueue, Proxy, QueueHandle, WEnum,
 };
 use wayland_protocols_wlr::layer_shell::v1::client::{
     zwlr_layer_shell_v1::{Layer, ZwlrLayerShellV1},
     zwlr_layer_surface_v1::{self, ZwlrLayerSurfaceV1},
 };
 
 use xkbcommon::xkb;
 
-use crate::tiny_font::{
-    draw_text_rgba_size, line_ascent_size, line_height_size, text_width_size,
-};
+use crate::tiny_font::{draw_text_rgba_size, line_ascent_size, line_height_size, text_width_size};
 use std::time::{Duration, Instant};
 
 use resvg::tiny_skia::{Pixmap, Transform};
 use resvg::usvg::{Options, TreeParsing};
 
 #[derive(Debug, Clone, Copy)]
 pub enum UiEvent {
     PressZ,
     PressEnter,
     PointerClick,
     AnyKey,
 }
 
 #[derive(Debug, Clone)]
 pub enum UiMode {
     BreakDue { snooze_secs: u64, can_snooze: bool },
     OnBreak { secs_left: u64 },
     BreakFinished,
 }
 
 pub struct Locker {
     conn: Connection,
     event_queue: EventQueue<State>,
     state: State,
 }
 
 #[derive(Debug, Clone, Copy)]
 pub struct UiColors {
     pub background: [u8; 4],
     pub foreground: [u8; 4],
 }
 
 struct Icon {
     width: u32,
     height: u32,
     rgba: Vec<u8>,
 }
 
 struct SurfaceCtx {
     _output: WlOutput,
     wl_surface: WlSurface,
     layer_surface: ZwlrLayerSurfaceV1,
     width: u32,
     height: u32,
     input_region: Option<WlRegion>,
     icon: Option<Icon>,
+    small_icon: Option<Icon>,
+    small_icon_size: u32,
 
     // SHM objects (recreated on resize/configure)
     shm_pool: Option<WlShmPool>,
     buffer: Option<WlBuffer>,
     shm_bytes: Vec<u8>,
     stride: i32,
 }
 
 #[derive(Debug, Clone)]
 enum FadeState {
     None,
     In { start: Instant },
     Out { start: Instant },
 }
 
 struct State {
     _registry: Option<wl_registry::WlRegistry>,
     compositor: Option<WlCompositor>,
     shm: Option<WlShm>,
     seat: Option<WlSeat>,
     layer_shell: Option<ZwlrLayerShellV1>,
     icon_tree: Option<resvg::Tree>,
 
     outputs: Vec<WlOutput>,
     surfaces: Vec<SurfaceCtx>,
@@ -137,54 +138,52 @@ fn draw_icon_rgba(
     buf: &mut [u8],
     width: u32,
     height: u32,
     x: i32,
     y: i32,
     icon: &Icon,
     tint: [u8; 3],
     alpha_mul: u8,
 ) {
     for iy in 0..icon.height {
         for ix in 0..icon.width {
             let px = x + ix as i32;
             let py = y + iy as i32;
             if px < 0 || py < 0 || (px as u32) >= width || (py as u32) >= height {
                 continue;
             }
             let src_idx = ((iy * icon.width + ix) * 4) as usize;
             let alpha = (icon.rgba[src_idx + 3] as u16 * alpha_mul as u16 / 255) as u8;
             if alpha == 0 {
                 continue;
             }
             let dst_idx = ((py as u32 * width + px as u32) * 4) as usize;
             let inv = 255u16.saturating_sub(alpha as u16);
             let a = alpha as u16;
             buf[dst_idx] = ((tint[0] as u16 * a + buf[dst_idx] as u16 * inv) / 255) as u8;
-            buf[dst_idx + 1] =
-                ((tint[1] as u16 * a + buf[dst_idx + 1] as u16 * inv) / 255) as u8;
-            buf[dst_idx + 2] =
-                ((tint[2] as u16 * a + buf[dst_idx + 2] as u16 * inv) / 255) as u8;
+            buf[dst_idx + 1] = ((tint[1] as u16 * a + buf[dst_idx + 1] as u16 * inv) / 255) as u8;
+            buf[dst_idx + 2] = ((tint[2] as u16 * a + buf[dst_idx + 2] as u16 * inv) / 255) as u8;
             buf[dst_idx + 3] = 255;
         }
     }
 }
 
 impl Locker {
     pub fn new(tx_ui: Sender<UiEvent>, colors: UiColors) -> Result<Self> {
         let conn = Connection::connect_to_env()?;
         let mut event_queue = conn.new_event_queue();
         let qh = event_queue.handle();
         let registry = conn.display().get_registry(&qh, ());
 
         let icon_tree = {
             let opts = Options::default();
             let usvg_tree = resvg::usvg::Tree::from_data(ICON_SVG, &opts).ok();
             usvg_tree.map(|tree| resvg::Tree::from_usvg(&tree))
         };
 
         let mut state = State {
             _registry: Some(registry),
             compositor: None,
             shm: None,
             seat: None,
             layer_shell: None,
             icon_tree,
@@ -287,116 +286,117 @@ impl Locker {
     pub fn is_fading(&self) -> bool {
         !matches!(self.state.fade, FadeState::None)
     }
 
     pub fn take_fade_in_complete(&mut self) -> bool {
         if self.state.fade_in_complete {
             self.state.fade_in_complete = false;
             true
         } else {
             false
         }
     }
 
     pub fn ensure_input_capture(&mut self) {
         self.set_input_capture(true);
     }
 
     pub fn update_fade(&mut self) -> bool {
         let (alpha, done, finished_fade_out) = match self.state.fade.clone() {
             FadeState::None => return false,
             FadeState::In { start } => {
                 let progress =
                     (Instant::now() - start).as_secs_f32() / FADE_IN_DURATION.as_secs_f32();
                 let p = progress.clamp(0.0, 1.0);
                 let alpha = (self.state.max_alpha as f32 * p).round() as u8;
-                let text_start = 1.0
-                    - (TEXT_FADE_IN_WINDOW.as_secs_f32() / FADE_IN_DURATION.as_secs_f32());
+                let text_start =
+                    1.0 - (TEXT_FADE_IN_WINDOW.as_secs_f32() / FADE_IN_DURATION.as_secs_f32());
                 let text_progress = if p <= text_start {
                     0.0
                 } else {
                     (p - text_start) / (1.0 - text_start)
                 };
-                self.state.text_alpha =
-                    (self.state.colors.foreground[3] as f32 * text_progress.clamp(0.0, 1.0))
-                        .round() as u8;
+                self.state.text_alpha = (self.state.colors.foreground[3] as f32
+                    * text_progress.clamp(0.0, 1.0))
+                .round() as u8;
                 (alpha, p >= 1.0, false)
             }
             FadeState::Out { start } => {
                 let progress =
                     (Instant::now() - start).as_secs_f32() / FADE_OUT_DURATION.as_secs_f32();
                 let p = progress.clamp(0.0, 1.0);
                 let alpha = (self.state.max_alpha as f32 * (1.0 - p)).round() as u8;
-                self.state.text_alpha =
-                    ((self.state.colors.foreground[3] as u16 * alpha as u16)
-                        / self.state.max_alpha as u16) as u8;
+                self.state.text_alpha = ((self.state.colors.foreground[3] as u16 * alpha as u16)
+                    / self.state.max_alpha as u16) as u8;
                 (alpha, p >= 1.0, true)
             }
         };
 
         if alpha != self.state.overlay_alpha {
             self.state.overlay_alpha = alpha;
             self.redraw_all();
         }
 
         if done {
             self.state.fade = FadeState::None;
             if !finished_fade_out {
                 self.state.fade_in_complete = true;
                 self.state.text_alpha = 255;
                 self.set_input_capture(true);
             }
         }
 
         done && finished_fade_out
     }
 
     fn set_input_capture(&mut self, enable: bool) {
         if self.state.input_captured == enable {
             return;
         }
         self.state.input_captured = enable;
         self.state.desired_capture = enable;
         if !self.state.overlay_active {
             return;
         }
 
         let interactivity = if enable {
             zwlr_layer_surface_v1::KeyboardInteractivity::Exclusive
         } else {
             zwlr_layer_surface_v1::KeyboardInteractivity::None
         };
 
         let compositor = match self.state.compositor.clone() {
             Some(compositor) => compositor,
             None => return,
         };
 
         let qh = self.event_queue.handle();
 
         for surface in self.state.surfaces.iter_mut() {
-            surface.layer_surface.set_keyboard_interactivity(interactivity);
+            surface
+                .layer_surface
+                .set_keyboard_interactivity(interactivity);
             if enable {
                 surface.wl_surface.set_input_region(None);
                 surface.input_region = None;
             } else {
                 let region = compositor.create_region(&qh, ());
                 surface.wl_surface.set_input_region(Some(&region));
                 surface.input_region = Some(region);
             }
             surface.wl_surface.commit();
         }
     }
 
     pub fn is_locked(&self) -> bool {
         self.state.overlay_active
     }
 
     pub fn lock(&mut self) -> Result<()> {
         if self.is_locked() {
             return Ok(());
         }
         let qh = self.event_queue.handle();
 
         // create a surface per output
         self.state.surfaces.clear();
         self.state.input_captured = false;
@@ -427,116 +427,102 @@ impl Locker {
             };
             layer_surface.set_keyboard_interactivity(interactivity);
             layer_surface.set_exclusive_zone(-1);
             layer_surface.set_size(0, 0);
             let input_region = if !self.state.desired_capture {
                 let region = compositor.create_region(&qh, ());
                 wl_surface.set_input_region(Some(&region));
                 Some(region)
             } else {
                 wl_surface.set_input_region(None);
                 None
             };
             wl_surface.commit();
 
             // placeholder until configure
             let (w, h) = (0u32, 0u32);
 
             self.state.surfaces.push(SurfaceCtx {
                 _output: out,
                 wl_surface,
                 layer_surface,
                 width: w,
                 height: h,
                 input_region,
                 icon: None,
+                small_icon: None,
+                small_icon_size: 0,
                 shm_pool: None,
                 buffer: None,
                 shm_bytes: vec![],
                 stride: (w as i32) * 4,
             });
         }
 
         // roundtrip so we receive configure sizes
         self.roundtrip()?;
 
         self.state.overlay_active = true;
         self.redraw_all();
         Ok(())
     }
 
     pub fn unlock(&mut self) {
         for surface in self.state.surfaces.drain(..) {
             surface.layer_surface.destroy();
             surface.wl_surface.destroy();
         }
         self.state.overlay_active = false;
         self.state.input_captured = false;
         self.state.desired_capture = false;
     }
 
     fn redraw_all(&mut self) {
         for i in 0..self.state.surfaces.len() {
             if let Err(err) = self.redraw_surface(i) {
                 eprintln!("redraw error: {err}");
             }
         }
     }
 
     fn redraw_surface(&mut self, idx: usize) -> Result<()> {
         let qh = self.event_queue.handle();
         let shm = match self.state.shm.clone() {
             Some(s) => s,
             None => return Ok(()),
         };
 
-        let (w, h) = {
-            let s = &self.state.surfaces[idx];
-            (s.width, s.height)
-        };
+        let s = &mut self.state.surfaces[idx];
+        let (w, h) = (s.width, s.height);
 
         if w == 0 || h == 0 {
             return Ok(());
         }
 
         let stride = (w as i32) * 4;
         let size = (stride as usize) * (h as usize);
 
-        // Allocate a simple RGBA buffer
-        let mut bytes = vec![0u8; size];
-
-        // Dim background: mostly opaque black
-        let bg_alpha = 255;
-        for px in bytes.chunks_exact_mut(4) {
-            px.copy_from_slice(&[
-                self.state.colors.background[0],
-                self.state.colors.background[1],
-                self.state.colors.background[2],
-                bg_alpha,
-            ]);
-        }
-
         let white = [
             self.state.colors.foreground[0],
             self.state.colors.foreground[1],
             self.state.colors.foreground[2],
             self.state.text_alpha,
         ];
         struct LineSpec {
             text: String,
             size: f32,
             alpha: f32,
         }
 
         let base_size = (w.min(h) as f32 / 16.0).clamp(42.0, 110.0);
         let large_size = (base_size * 1.35).clamp(56.0, 150.0);
         let small_size = (base_size * 0.7).clamp(28.0, 80.0);
 
         let lines = match &self.state.ui_mode {
             UiMode::BreakDue {
                 snooze_secs,
                 can_snooze,
             } => {
                 let l1 = "BREAK STARTING".to_string();
                 let l2 = if *can_snooze {
                     let m = snooze_secs / 60;
                     let s = snooze_secs % 60;
@@ -571,158 +557,182 @@ impl Locker {
                         size: small_size,
                         alpha: 0.65,
                     },
                 ]
             }
             UiMode::BreakFinished => vec![
                 LineSpec {
                     text: "Break Complete.".to_string(),
                     size: base_size,
                     alpha: 1.0,
                 },
                 LineSpec {
                     text: "Press any key to continue".to_string(),
                     size: small_size,
                     alpha: 0.65,
                 },
             ],
         };
 
         let icon_size = {
             let mut size = (w.min(h) / 6).max(ICON_BASE_SIZE);
             size = size.min(ICON_BASE_SIZE * 2);
             size
         };
 
-        if self.state.surfaces[idx]
+        let needs_icon = s
             .icon
             .as_ref()
             .map(|icon| icon.width != icon_size)
-            .unwrap_or(true)
-        {
+            .unwrap_or(true);
+        if needs_icon {
             if let Some(tree) = &self.state.icon_tree {
-                self.state.surfaces[idx].icon = render_icon(tree, icon_size);
+                s.icon = render_icon(tree, icon_size);
             }
         }
 
-        let icon_height = self.state.surfaces[idx]
-            .icon
-            .as_ref()
-            .map(|icon| icon.height as i32)
-            .unwrap_or(0);
-
-        let text_height: i32 = lines
-            .iter()
-            .map(|line| line_height_size(line.size))
-            .sum();
-        let total_height =
-            icon_height + if icon_height > 0 { ICON_GAP } else { 0 } + text_height;
+        let icon = s.icon.as_ref();
+        let icon_height = icon.map(|icon| icon.height as i32).unwrap_or(0);
+
+        let small_icon = if matches!(self.state.fade, FadeState::In { .. }) {
+            let small_size = (icon_size / 3).max(24);
+            let needs_icon = s.small_icon_size != small_size || s.small_icon.is_none();
+            if needs_icon {
+                if let Some(tree) = &self.state.icon_tree {
+                    s.small_icon = render_icon(tree, small_size);
+                    s.small_icon_size = small_size;
+                }
+            }
+            s.small_icon.as_ref()
+        } else {
+            None
+        };
+
+        // Dim background: mostly opaque black
+        let bg_alpha = 255;
+        let bytes = &mut s.shm_bytes;
+        bytes.resize(size, 0u8);
+        for px in bytes.chunks_exact_mut(4) {
+            px.copy_from_slice(&[
+                self.state.colors.background[0],
+                self.state.colors.background[1],
+                self.state.colors.background[2],
+                bg_alpha,
+            ]);
+        }
+
+        let text_height: i32 = lines.iter().map(|line| line_height_size(line.size)).sum();
+        let total_height = icon_height + if icon_height > 0 { ICON_GAP } else { 0 } + text_height;
         let base_y = ((h as i32 - total_height) / 2).max(0);
 
         let tint = [
             self.state.colors.foreground[0],
             self.state.colors.foreground[1],
             self.state.colors.foreground[2],
         ];
 
-        if let Some(icon) = &self.state.surfaces[idx].icon {
+        if let Some(icon) = icon {
             let icon_x = ((w as i32 - icon.width as i32) / 2).max(0);
             if self.state.text_alpha > 0 {
-                draw_icon_rgba(&mut bytes, w, h, icon_x, base_y, icon, tint, self.state.text_alpha);
+                draw_icon_rgba(
+                    bytes,
+                    w,
+                    h,
+                    icon_x,
+                    base_y,
+                    icon,
+                    tint,
+                    self.state.text_alpha,
+                );
             }
         }
 
         let text_start_y = base_y + icon_height + if icon_height > 0 { ICON_GAP } else { 0 };
         let mut line_y = text_start_y;
         for line in &lines {
             let ascent = line_ascent_size(line.size);
             let line_width = text_width_size(&line.text, line.size);
             let base_x = ((w as i32 - line_width) / 2).max(0);
             let alpha = ((self.state.text_alpha as f32) * line.alpha).round() as u8;
             let rgba = [white[0], white[1], white[2], alpha];
             draw_text_rgba_size(
-                &mut bytes,
+                bytes,
                 w,
                 h,
                 base_x,
                 line_y + ascent,
                 &line.text,
                 rgba,
                 line.size,
             );
             line_y += line_height_size(line.size);
         }
 
-        if matches!(self.state.fade, FadeState::In { .. }) {
-            let small_size = (icon_size / 3).max(24);
-            let small_icon = self.state.icon_tree.as_ref().and_then(|tree| render_icon(tree, small_size));
-            if let Some(icon) = small_icon {
-                let pad = 20;
-                let x = w as i32 - icon.width as i32 - pad;
-                let y = h as i32 - icon.height as i32 - pad;
-                draw_icon_rgba(&mut bytes, w, h, x, y, &icon, tint, 255);
-            }
+        if let Some(icon) = small_icon {
+            let pad = 20;
+            let x = w as i32 - icon.width as i32 - pad;
+            let y = h as i32 - icon.height as i32 - pad;
+            draw_icon_rgba(bytes, w, h, x, y, icon, tint, 255);
         }
 
         let fade = self.state.overlay_alpha as u16;
         for px in bytes.chunks_exact_mut(4) {
             px[0] = ((px[0] as u16 * fade) / 255) as u8;
             px[1] = ((px[1] as u16 * fade) / 255) as u8;
             px[2] = ((px[2] as u16 * fade) / 255) as u8;
             px[3] = fade as u8;
         }
 
         // Create a shm pool and buffer each redraw (MVP).
         // Optimization later: reuse pool/buffer and only rewrite bytes.
         let fd = rustix::fs::memfd_create("interlude-frame", rustix::fs::MemfdFlags::CLOEXEC)
             .map_err(|e| anyhow!("memfd_create: {e}"))?;
         rustix::fs::ftruncate(&fd, size as u64).map_err(|e| anyhow!("ftruncate: {e}"))?;
         let raw_fd = fd.into_raw_fd();
         let file = unsafe { std::fs::File::from_raw_fd(raw_fd) };
 
         // mmap and copy bytes
-        let mut map = unsafe { memmap2::MmapMut::map_mut(&file) }
-            .map_err(|e| anyhow!("mmap: {e}"))?;
+        let mut map =
+            unsafe { memmap2::MmapMut::map_mut(&file) }.map_err(|e| anyhow!("mmap: {e}"))?;
         map[..].copy_from_slice(&bytes);
         map.flush().ok();
 
         let pool = shm.create_pool(file.as_fd(), size as i32, &qh, ());
         let buffer = pool.create_buffer(
             0,
             w as i32,
             h as i32,
             stride,
             wayland_client::protocol::wl_shm::Format::Argb8888,
             &qh,
             (),
         );
 
         {
             let s = &mut self.state.surfaces[idx];
             s.shm_pool = Some(pool);
             s.buffer = Some(buffer.clone());
-            s.shm_bytes = bytes;
             s.stride = stride;
         }
 
         let s = &self.state.surfaces[idx];
         s.wl_surface.attach(Some(&buffer), 0, 0);
         s.wl_surface.damage_buffer(0, 0, w as i32, h as i32);
         s.wl_surface.commit();
         Ok(())
     }
 }
 
 // ---------- Dispatch impls ----------
 
 impl Dispatch<wl_keyboard::WlKeyboard, ()> for State {
     fn event(
         state: &mut Self,
         _proxy: &wl_keyboard::WlKeyboard,
         event: wl_keyboard::Event,
         _data: &(),
         _conn: &Connection,
         _qh: &QueueHandle<Self>,
     ) {
         match event {
             wl_keyboard::Event::Keymap { format, fd, size } => {
                 if format != WEnum::Value(wl_keyboard::KeymapFormat::XkbV1) {
@@ -846,76 +856,78 @@ impl Dispatch<ZwlrLayerSurfaceV1, ()> for State {
                             }
                         }
                         break;
                     }
                 }
             }
             zwlr_layer_surface_v1::Event::Closed => {
                 state.overlay_active = false;
                 state.surfaces.clear();
             }
             _ => {}
         }
     }
 }
 
 impl Dispatch<wl_registry::WlRegistry, ()> for State {
     fn event(
         state: &mut Self,
         proxy: &wl_registry::WlRegistry,
         event: wl_registry::Event,
         _data: &(),
         _conn: &Connection,
         qh: &QueueHandle<Self>,
     ) {
         match event {
-            wl_registry::Event::Global { name, interface, version } => {
-                match interface.as_str() {
-                    "wl_compositor" if state.compositor.is_none() => {
-                        let ver = version.min(WlCompositor::interface().version);
-                        state.compositor = Some(proxy.bind(name, ver, qh, ()));
-                    }
-                    "wl_shm" if state.shm.is_none() => {
-                        let ver = version.min(WlShm::interface().version);
-                        state.shm = Some(proxy.bind(name, ver, qh, ()));
-                    }
-                    "wl_seat" if state.seat.is_none() => {
-                        let ver = version.min(WlSeat::interface().version);
-                        state.seat = Some(proxy.bind(name, ver, qh, ()));
-                    }
-                    "wl_output" => {
-                        let ver = version.min(WlOutput::interface().version);
-                        let out = proxy.bind(name, ver, qh, ());
-                        state.outputs.push(out);
-                    }
-                    "zwlr_layer_shell_v1" if state.layer_shell.is_none() => {
-                        let ver = version.min(ZwlrLayerShellV1::interface().version);
-                        state.layer_shell = Some(proxy.bind(name, ver, qh, ()));
-                    }
-                    _ => {}
+            wl_registry::Event::Global {
+                name,
+                interface,
+                version,
+            } => match interface.as_str() {
+                "wl_compositor" if state.compositor.is_none() => {
+                    let ver = version.min(WlCompositor::interface().version);
+                    state.compositor = Some(proxy.bind(name, ver, qh, ()));
                 }
-            }
+                "wl_shm" if state.shm.is_none() => {
+                    let ver = version.min(WlShm::interface().version);
+                    state.shm = Some(proxy.bind(name, ver, qh, ()));
+                }
+                "wl_seat" if state.seat.is_none() => {
+                    let ver = version.min(WlSeat::interface().version);
+                    state.seat = Some(proxy.bind(name, ver, qh, ()));
+                }
+                "wl_output" => {
+                    let ver = version.min(WlOutput::interface().version);
+                    let out = proxy.bind(name, ver, qh, ());
+                    state.outputs.push(out);
+                }
+                "zwlr_layer_shell_v1" if state.layer_shell.is_none() => {
+                    let ver = version.min(ZwlrLayerShellV1::interface().version);
+                    state.layer_shell = Some(proxy.bind(name, ver, qh, ()));
+                }
+                _ => {}
+            },
             wl_registry::Event::GlobalRemove { .. } => {}
             _ => {}
         }
     }
 }
 
 // Boilerplate: unused but required for compilation in some setups
 impl Dispatch<wl_output::WlOutput, ()> for State {
     fn event(
         _state: &mut Self,
         _proxy: &wl_output::WlOutput,
         _event: wl_output::Event,
         _data: &(),
         _conn: &Connection,
         _qh: &QueueHandle<Self>,
     ) {
     }
 }
 
 impl Dispatch<WlBuffer, ()> for State {
     fn event(
         _state: &mut Self,
         _proxy: &WlBuffer,
         _event: wl_buffer::Event,
         _data: &(),
@@ -963,55 +975,59 @@ impl Dispatch<WlCompositor, ()> for State {
 
 impl Dispatch<WlShm, ()> for State {
     fn event(
         _state: &mut Self,
         _proxy: &WlShm,
         _event: wayland_client::protocol::wl_shm::Event,
         _data: &(),
         _conn: &Connection,
         _qh: &QueueHandle<Self>,
     ) {
     }
 }
 
 impl Dispatch<WlSeat, ()> for State {
     fn event(
         state: &mut Self,
         proxy: &WlSeat,
         event: wayland_client::protocol::wl_seat::Event,
         _data: &(),
         _conn: &Connection,
         qh: &QueueHandle<Self>,
     ) {
         match event {
             wayland_client::protocol::wl_seat::Event::Capabilities { capabilities } => {
                 let has_keyboard = match capabilities {
-                    WEnum::Value(caps) => caps.contains(wayland_client::protocol::wl_seat::Capability::Keyboard),
+                    WEnum::Value(caps) => {
+                        caps.contains(wayland_client::protocol::wl_seat::Capability::Keyboard)
+                    }
                     WEnum::Unknown(_) => false,
                 };
                 let has_pointer = match capabilities {
-                    WEnum::Value(caps) => caps.contains(wayland_client::protocol::wl_seat::Capability::Pointer),
+                    WEnum::Value(caps) => {
+                        caps.contains(wayland_client::protocol::wl_seat::Capability::Pointer)
+                    }
                     WEnum::Unknown(_) => false,
                 };
 
                 if has_keyboard && state.keyboard.is_none() {
                     state.keyboard = Some(proxy.get_keyboard(qh, ()));
                 } else if !has_keyboard {
                     if let Some(kbd) = state.keyboard.take() {
                         kbd.release();
                     }
                     state.xkb_state = None;
                     state.xkb_keymap = None;
                 }
 
                 if has_pointer && state.pointer.is_none() {
                     state.pointer = Some(proxy.get_pointer(qh, ()));
                 } else if !has_pointer {
                     if let Some(ptr) = state.pointer.take() {
                         ptr.release();
                     }
                 }
             }
             _ => {}
         }
     }
 }
@@ -1028,34 +1044,36 @@ impl Dispatch<WlSurface, ()> for State {
     }
 }
 
 impl Dispatch<WlRegion, ()> for State {
     fn event(
         _state: &mut Self,
         _proxy: &WlRegion,
         _event: wayland_client::protocol::wl_region::Event,
         _data: &(),
         _conn: &Connection,
         _qh: &QueueHandle<Self>,
     ) {
     }
 }
 
 impl Dispatch<wl_pointer::WlPointer, ()> for State {
     fn event(
         state: &mut Self,
         _proxy: &wl_pointer::WlPointer,
         event: wl_pointer::Event,
         _data: &(),
         _conn: &Connection,
         _qh: &QueueHandle<Self>,
     ) {
         match event {
-            wl_pointer::Event::Button { state: btn_state, .. } => {
+            wl_pointer::Event::Button {
+                state: btn_state, ..
+            } => {
                 if btn_state == WEnum::Value(wl_pointer::ButtonState::Pressed) {
                     let _ = state.tx_ui.send(UiEvent::PointerClick);
                 }
             }
             _ => {}
         }
     }
 }

